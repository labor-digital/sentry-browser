/*
 * Copyright 2019 LABOR.digital
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Last modified: 2019.11.17 at 11:42
 */
import * as SentryRoot from "@sentry/browser";
import {BrowserOptions, Severity} from "@sentry/browser";

export default class Sentry {

	/**
	 * True as soon as sentry was initialized
	 */
	protected static _isInitialized: boolean;

	/**
	 * As long as this is null we use the automatic activity detection,
	 * if this is either true or false we will use this property to determine activity
	 */
	protected static _manualActiveState: boolean;

	/**
	 * Holds the determined, dynamic activity state
	 */
	protected static _dynamicActivityState: boolean;

	/**
	 * Holds the sentry configuration
	 */
	protected static _sentryConfig: BrowserOptions;

	/**
	 * Captures an exception event and sends it to Sentry.
	 *
	 * @param exception An exception-like object.
	 * @returns The generated eventId.
	 */
	public static captureException(exception: any): string {
		if (!Sentry.isActivated()) return "";
		return SentryRoot.captureException(exception);
	}

	/**
	 * Captures a message event and sends it to Sentry.
	 *
	 * @param message The message to send to Sentry.
	 * @param level Define the level of the message.
	 * @returns The generated eventId.
	 */
	public static captureMessage(message: string, level?: Severity): string {
		if (!Sentry.isActivated()) return "";
		return SentryRoot.captureMessage(message, level);
	}

	/**
	 * We use NODE_ENV === "production" to automatically detect
	 * if sentry logging should be enabled. If you want to force the activity state you can always use this method to
	 * set the activity manually.
	 *
	 * Keep in mind, that even if you set this to TRUE, but your configuration is incomplete nothing will be logged!
	 */
	public static manualActivation(state: boolean): void {
		Sentry._manualActiveState = state;
	}

	/**
	 * By default, the class will try to load the basic configuration using the config.json file
	 * that was generated by the sentry-release build step, but you may use this method either to
	 * provide additional configuration for sentry or to provide the whole configuration without using the build step.
	 */
	public static setSentryConfig(config: BrowserOptions): void {
		Sentry._sentryConfig = config;
	}

	/**
	 * Checks if the sentry logging is activated, by validating if the class was correctly initialized
	 * @return bool
	 */
	public static isActivated(): boolean {
		// Check if the class is activated
		if (Sentry._manualActiveState === false) return false;
		if (typeof Sentry._dynamicActivityState === "undefined") {
			Sentry._dynamicActivityState = process.env.NODE_ENV === "production";
		}
		if (Sentry._dynamicActivityState === false && Sentry._manualActiveState !== true) return false;

		// Check if the class is initialized
		if (Sentry._isInitialized) return true;
		Sentry.initialize();
		return Sentry._isInitialized;
	}

	/**
	 * Internal helper that is used to initialize the sentry client based on the configuration
	 * we got from setSentryConfig() and the possible auto config file at config.json
	 * @return bool
	 */
	protected static initialize() {
		if (Sentry._isInitialized) return true;

		// Try to load the config file
		const autoConfig = typeof process.env.LABOR_SENTRY_CONFIG !== "undefined" ? process.env.LABOR_SENTRY_CONFIG : {};

		// Merge with possibly given config
		let config = typeof Sentry._sentryConfig !== "object" ? {} : Sentry._sentryConfig;
		for (let k in autoConfig) {
			if (!autoConfig.hasOwnProperty(k)) continue;
			if (typeof config[k] === "undefined") config[k] = autoConfig[k];
		}

		// Check if we got a dsn
		if (typeof config.dsn === "undefined") return false;

		// Register event extender if the given error provides the extra data
		if (typeof config.beforeSend === "undefined")
			config.beforeSend = function (event, hint): Promise<SentryRoot.Event> {
				return new Promise<SentryRoot.Event>(resolve => {
					// Ignore if we did not get any additional data on the error
					if (typeof (hint.originalException as any).getSentryExtra === "undefined")
						return resolve(event);

					// Execute the extra resolving
					const extra = (hint.originalException as any).getSentryExtra(event, hint);

					// Handle a promise result
					if (typeof extra === "object" && typeof extra.then === "function" && typeof extra.catch === "function") {
						extra.then(v => {
							event.extra = {
								...event.extra,
								labor: v
							};
							resolve(event);
						});
						return;
					}

					// Handle all other results
					event.extra = {
						...event.extra,
						labor: extra
					};
					resolve(event);

				});
			};

		// Initialize sentry
		SentryRoot.init(config);
		Sentry._isInitialized = true;
		return true;
	}
}